def parse_hausdorff(ml_log, log=None, print_output=False):
    """Parse the ml_log file generated by the hausdorff_distance function.

    Args:
        ml_log (str): MeshLab log file to parse
        log (str): filename to log output

    Returns:
        dict: dictionary with the following keys:
            number_points (int): number of points in mesh
            min_distance (float): minimum hausdorff distance
            max_distance (float): maximum hausdorff distance
            mean_distance (float): mean hausdorff distance
            rms_distance (float): root mean square distance

    """
    hausdorff_distance = {'min_distance': 0.0, 'max_distance': 0.0, 'mean_distance': 0.0, 'rms_distance': 0.0, 'number_points': 0}
    with open(ml_log) as fread:
        result = fread.readlines()
        data = ''
        for (idx, line) in enumerate(result):
            m = re.match('\\s*Sampled (\\d+) pts.*', line)
            if m is not None:
                hausdorff_distance['number_points'] = int(m.group(1))
            if 'Hausdorff Distance computed' in line:
                data = result[idx + 2]
        m = re.match('\\D+(\\d+\\.*\\d*)\\D+(\\d+\\.*\\d*)\\D+(\\d+\\.*\\d*)\\D+(\\d+\\.*\\d*)', data)
        hausdorff_distance['min_distance'] = float(m.group(1))
        hausdorff_distance['max_distance'] = float(m.group(2))
        hausdorff_distance['mean_distance'] = float(m.group(3))
        hausdorff_distance['rms_distance'] = float(m.group(4))
        for (key, value) in hausdorff_distance.items():
            if log is not None:
                log_file = open(log, 'a')
                log_file.write('{:16} = {}\n'.format(key, value))
                log_file.close()
            elif print_output:
                print('{:16} = {}'.format(key, value))
        return hausdorff_distance