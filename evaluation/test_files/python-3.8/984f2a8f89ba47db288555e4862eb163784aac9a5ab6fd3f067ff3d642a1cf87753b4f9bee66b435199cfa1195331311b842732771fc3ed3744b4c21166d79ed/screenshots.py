"""
trosnoth.tools.screenshots: programmatically generate screenshots

This module generates Trosnoth screenshots using dumped data
representing the Trosnoth world and UI state. It aims to allow
screenshot data to be generated in one version of Trosnoth and used to
build screenshots in later versions with minimal changes to the
screenshot data. To do this, the general philosophy of this module is
that screenshot data should contain what's genuinely necessary to
generate a Trosnoth screenshot, and anything else can be filled in with
reasonable defaults at the time of generating the screenshot.

Screenshot data is generated by GameInterface.get_screenshot_info(). The
simplest way to get this data is to activate globaldebug.enabled and
globaldebug.debug_key_screenshots, then press the debug key (default
middle mouse button) during a game or replay.
"""
if __name__ == '__main__':
    import os
    import sys
    sys.path.insert(0, os.path.join(os.path.abspath(os.path.dirname(__file__)), '..', '..'))
    from trosnoth.qtreactor import declare_this_module_requires_asyncio_reactor
    declare_this_module_requires_asyncio_reactor()
import ast
import math
import os
import pprint
import sys
import pygame
from trosnoth.const import LEFT_STATE, RIGHT_STATE, JUMP_STATE, DOWN_STATE, HOOK_ATTACHED, TICK_PERIOD, COLLECTABLE_COIN_LIFETIME
from trosnoth.gui.app import get_pygame_runner
from trosnoth.gui.framework.framework import CompoundElement
from trosnoth.model.player import Player, Emote
from trosnoth.model.shot import Shot
from trosnoth.model.upgrades import GunType, gun_type_by_code, DefaultGun
from trosnoth.run.common import CURSOR_HOTSPOT, load_cursor_image
from trosnoth.trosnothgui.common import override_mouse_pos, get_mouse_pos
DEFAULT_SIZE = (1600, 900)

def add_defaults(data, defaults):
    """
    Modifies `data` in-place.
    """
    for (k, v) in defaults.items():
        if callable(v):
            v = v()
        if k not in data:
            data[k] = v

def get_screenshot_data(game_interface):
    """
    Returns a basic dict that can be sent to make_screenshot() to
    generate a screenshot. This will not contain everything on the
    screen, just enough to generate a representative screenshot. Any
    extra required data can be added to the dict by hand.
    """
    result = {'world': game_interface.gameViewer.worldgui.get_screenshot_info()}
    if game_interface.player:
        result['view'] = game_interface.player.nick
    else:
        game_viewer = game_interface.gameViewer
        result['view'] = 'replay' if game_viewer.replay else 'spectate'
        result['focus'] = game_viewer.viewManager.get_screenshot_focus()
    scenario_info = game_interface.gameInfoDisplay.get_screenshot_scenario()
    if scenario_info:
        result['scenario'] = scenario_info
    shop_info = game_interface.detailsInterface.radialUpgradeMenu.get_screenshot_info()
    if shop_info:
        result['shop'] = shop_info
        (mx, my) = get_mouse_pos()
        (sw, sh) = game_interface.app.screenManager.size
        result['mouse'] = (mx / sw, my / sh)
    log_info = game_interface.detailsInterface.message_log.get_screenshot_info()
    if log_info:
        result['log'] = log_info
    return result
WORLD_ABILITY_DEFAULTS = {'balanceTeams': True, 'leaveFriendlyZones': True, 'renaming': False, 'respawn': True, 'respawn_time_factor': 1, 'upgrades': True, 'zoneCaps': True}

def restore_world(game, world_data):
    restore_dict = {'abilities': world_data.get('abilities', {}), 'coins': [], 'grenades': [], 'lastTickId': world_data.get('last_tick_id', 0), 'loading': world_data.get('loading', False), 'mode': world_data.get('mode', 'Normal'), 'physics': world_data.get('physics', {}), 'projectiles': [], 'speed': world_data.get('speed', 1.0), 'trosball': None, 'uiOptions': world_data.get('ui_options', {}), 'worldMap': world_data['world_map'], 'zones': world_data['zones']}
    add_defaults(restore_dict['abilities'], WORLD_ABILITY_DEFAULTS)
    if 'macguffins' in world_data:
        restore_dict['macguffins'] = world_data['macguffins']
    clock = world_data.get('clock', None)
    restore_dict['clock'] = clock_data = {'counting': True, 'flashBelow': 10, 'showing': True, 'upwards': False, 'value': 20 * 60}
    if clock is None:
        clock_data['showing'] = False
    else:
        clock_data['value'] = clock
    restore_dict['upgrades'] = upgrade_data = []
    for upgrade_code in world_data.get('disabled_upgrades', b''):
        upgrade_data.append({'type': upgrade_code, 'cost': 10, 'time': 10, 'enabled': False})
    if (team_data := world_data['teams']):
        (team_a, team_b) = team_data
    else:
        team_a = team_b = {}
    restore_dict['teams'] = [restore_team_data(team_a, b'A', 'Defaulticons'), restore_team_data(team_b, b'B', 'Standardators')]
    tid_by_name = {team_data['name']: team_data['id'] for team_data in restore_dict['teams']}
    restore_dict['shots'] = restore_shots = []
    shot_id = 1
    for shot_data in world_data.get('shots', []):
        team = game.world.getTeam(tid_by_name[shot_data['team']])
        pos = shot_data['points'][-1]
        vel = (0, 0)
        gun_type = gun_type_by_code[shot_data.get('gun', DefaultGun.gun_code)]
        lifetime = 1
        shot = Shot(game.world, shot_id, team, None, pos, vel, gun_type, lifetime)
        shot_id += 1
        restore_shots.append(shot.dump())
    restore_dict['players'] = restore_players = []
    next_id = 1
    for player_data in world_data.get('players', []):
        player = Player(world=game.world, nick=player_data['nick'], team=game.world.getTeam(tid_by_name[player_data['team']]), id_=bytes([next_id]), head=head if (head := player_data['head']) != 'bot' else 0, bot=head == 'bot', dead=player_data.get('health', 1) == 0)
        next_id += 1
        keys = player_data.get('keys', b'').lower()
        player.updateState(LEFT_STATE, b'l' in keys)
        player.updateState(RIGHT_STATE, b'r' in keys)
        player.updateState(JUMP_STATE, b'j' in keys)
        player.updateState(DOWN_STATE, b'd' in keys)
        (player.xVel, player.yVel) = player_data.get('vel', (0, 0))
        player.lookAt(player_data['angle'], player_data.get('thrust', 1))
        player.setPos(player_data['pos'])
        player.timeTillRespawn = player_data.get('respawn_in', 0)
        player.coins = player_data.get('coins', 100)
        player.grabbedSurfaceAngle = player_data.get('grab_surface_angle', None)
        player.max_health = player_data.get('max_health', 1)
        player.health = player_data.get('health', 1)
        player.abilities.restoreState(player_data.get('abilities', {}))
        player.readyToStart = player_data.get('ready', False)
        for gun_data in player_data.get('guns', []):
            gun = GunType.build_from_data(player, gun_data)
            player.guns.instances[type(gun)] = gun
        if 'gun' in player_data:
            player.guns.selected = player.guns.get(player_data['gun'])
        if 'reload' in player_data:
            player.guns.standard_reload_time = game.world.physics.playerNeutralReloadTime
            player.guns.reload_from = player.guns.standard_reload_time
            player.guns.reload_time = player.guns.standard_reload_time * player_data['reload']
        if 'emote' in player_data:
            player.emote = Emote(player_data['emote'])
        if 'hook' in player_data:
            hook = player.grapplingHook
            hook.oldPos = hook.pos = player_data['hook']
            hook.hookState = HOOK_ATTACHED
        if 'items' in player_data:
            player.items.restore(player_data['items'])
        restore_players.append(player.dump())
    pid_by_nick = {p['nick']: p['id'] for p in restore_dict['players']}
    restore_dict['scoreboard'] = scoreboard_data = {'playerScores': {p['id']: 0 for p in restore_dict['players']}, 'playerScoresEnabled': False, 'teamScores': {t['id']: 0 for t in restore_dict['teams']}, 'teamScoresEnabled': False}
    if (player_scores := world_data.get('player_scores')):
        scoreboard_data['playerScoresEnabled'] = True
        for (nick, score) in player_scores.items():
            scoreboard_data['playerScores'][pid_by_nick[nick]] = score
    if (team_scores := world_data.get('team_scores')):
        scoreboard_data['teamScoresEnabled'] = True
        for (team_data, team_score) in zip(restore_dict['teams'], team_scores):
            scoreboard_data['teamScores'][team_data['id']] = team_score
    if (trosball_data := world_data.get('trosball')):
        if 'player' in trosball_data:
            restore_dict['trosball'] = {'catchTicksAgo': 0, 'playerId': pid_by_nick[trosball_data['player']], 'pos': None, 'vel': None}
            if trosball_data.get('flashing'):
                restore_dict['trosball']['catchTicksAgo'] = game.world.physics.trosballExplodeTime // TICK_PERIOD - 1
        else:
            restore_dict['trosball'] = {'pos': trosball_data['pos'], 'vel': (0, 0), 'catchTicksAgo': None, 'playerId': None}
    for (mine_id, mine_data) in enumerate(world_data.get('mines', [])):
        restore_dict['projectiles'].append({'id': mine_id, 'player': pid_by_nick.get(mine_data.get('player')), 'team': tid_by_name.get(mine_data['team']), 'initial_angle': 0, 'pos': mine_data['pos'], 'stuck_angle': mine_data.get('stuck_angle'), 'countdown': 1 if mine_data.get('inactive') else 0, 'stops': None, 'throw_angle': 0})
    for (coin_id, coin_data) in enumerate(world_data.get('coins', [])):
        restore_dict['coins'].append({'id': coin_id, 'createdAgo': (COLLECTABLE_COIN_LIFETIME - 1) // TICK_PERIOD if coin_data['fading'] else 0, 'pos': coin_data['pos'], 'xVel': 0, 'yVel': 0, 'value': coin_data.get('value')})
    for grenade_data in world_data.get('grenades', []):
        restore_dict['grenades'].append({'player': pid_by_nick[grenade_data['player']], 'pos': grenade_data['pos'], 'yVel': 0, 'xVel': 0, 'timeLeft': 1})
    game.world.restoreEverything(restore_dict)

def restore_team_data(team_data, team_id, default_name):
    result = {'abilities': team_data, 'boosts': [], 'id': team_id, 'name': team_data.get('name', default_name)}
    for boost_data in team_data.get('active_boosts', []):
        result['boosts'].append({'code': boost_data['code'], 'cost': 0, 'time': boost_data['time']})
    for boost_data in team_data.get('pending_boosts', []):
        result['boosts'].append({'code': boost_data['code'], 'cost': boost_data['cost'], 'time': 100})
    return result

def make_screenshot(screenshot_data, size=DEFAULT_SIZE):
    """
    :param screenshot_data: the return value of
        GameInterface.get_screenshot_info(). The simplest way to get
        this data is to activate globaldebug.enabled and
        globaldebug.debug_key_screenshots, then press the debug key
        (default middle mouse button) during a game or replay.
    :param size: the screenshot size
    :return: a pygame surface
    """
    from trosnoth.game import LocalGame
    pygame_runner = get_pygame_runner()
    already_showing = pygame_runner.is_showing()
    game = LocalGame()
    restore_world(game, screenshot_data['world'])
    game.achievementManager.stop()
    if not already_showing:
        pygame.display.set_mode(size)
    try:
        if 'mouse' in screenshot_data:
            (fx, fy) = screenshot_data['mouse']
            (mx, my) = (round(fx * size[0]), round(fy * size[1]))
            with override_mouse_pos((mx, my)):
                surface = _make_screenshot(game, screenshot_data, size)
            surface.blit(load_cursor_image(), (mx - CURSOR_HOTSPOT[0], my - CURSOR_HOTSPOT[1]))
            return surface
        with override_mouse_pos((size[0] // 2, size[1] // 2)):
            return _make_screenshot(game, screenshot_data, size)
    finally:
        if not already_showing:
            pygame.display.quit()

def _make_screenshot(game, screenshot_data, size):
    from trosnoth.run.common import TrosnothApp
    from trosnoth.trosnothgui.ingame.gameInterface import GameInterface
    app = TrosnothApp()
    app.screenManager.set_interface(CompoundElement(app))
    app.settings.display.show_timings = False
    app.settings.display.show_range = True
    app.settings.display.disable_shop_buttons = False
    app.settings.display.upscale = False
    app.settings.display.detail_level = 'full'
    app.settings.display.update_detail_flags()
    try:
        game_interface = GameInterface(app, game, replay=screenshot_data['view'] == 'replay', spectate=screenshot_data['view'] == 'spectate')
        game_interface.keyMapping.load('')
        if screenshot_data['view'] not in {'replay', 'spectate'}:
            player = [p for p in game.world.players if p.nick == screenshot_data['view']][0]
            player.agent = GameInterface(app, game)
            game_interface.setPlayer(player)
        elif 'focus' in screenshot_data:
            game_interface.setFocus(screenshot_data['focus'])
        if 'shop' in screenshot_data:
            game_interface.detailsInterface.radialUpgradeMenu.restore_screenshot_info(screenshot_data['shop'])
        game_interface.detailsInterface.menuManager.restore_screenshot_info(screenshot_data.get('menu', {}))
        game_interface.gameInfoDisplay.restore_screenshot_scenario(screenshot_data.get('scenario', []))
        game_interface.detailsInterface.message_log.restore_screenshot_info(screenshot_data.get('log', []))
        game_interface.tick(0)
        game_interface.gameViewer.worldgui.restore_screenshot_info(screenshot_data['world'])
        screen = pygame.Surface(size)
        app.declarative_renderer.pre_draw()
        game_interface.draw(screen)
    finally:
        app.stop()
    return screen

class NodeChecker(ast.NodeVisitor):
    ALLOWED_NAMES = {'nan', 'None', 'False', 'True'}

    def visit_Name(self, node):
        if node.id not in self.ALLOWED_NAMES:
            raise ValueError('malformed node or string: {}'.format(node))
        return self.generic_visit(node)

def literal_eval(source, filename='<string>'):
    tree = ast.parse(source, mode='eval')
    NodeChecker().visit(tree)
    return eval(compile(tree, filename, 'eval'), {'nan': math.nan})

def process_screenshot_file(filename, size=DEFAULT_SIZE):
    pygame_running = get_pygame_runner().is_showing()
    if not pygame_running:
        pygame.display.set_mode(size)
    try:
        counter = 1
        try:
            os.mkdir('screenshots')
        except FileExistsError:
            pass
        while os.path.isfile('screenshots/%03d.png' % counter):
            counter += 1
        with open(filename) as f:
            all_lines = f.readlines()
        block = ''
        while all_lines:
            pygame.event.get()
            block += all_lines.pop(0)
            try:
                data = literal_eval(block)
            except SyntaxError:
                continue
            block = ''
            print(counter)
            pygame.image.save(make_screenshot(data, size), 'screenshots/%03d.png' % counter)
            with open('screenshots/%03d.txt' % counter, 'w') as w:
                pprint.pprint(data, w)
            with open(filename, 'w') as f:
                f.write(''.join(all_lines))
            counter += 1
        if block:
            print('Error reading data:')
            literal_eval(block)
        print('finished')
    finally:
        if not pygame_running:
            pygame.display.quit()

def rebuild_screenshot(filename, size=DEFAULT_SIZE):
    (base_path, _) = os.path.splitext(filename)
    with open(base_path + '.txt') as f:
        data = literal_eval(f.read())
    pygame.image.save(make_screenshot(data, size), base_path + '.png')
if __name__ == '__main__':
    if len(sys.argv) <= 1:
        process_screenshot_file('screenshots.txt')
    else:
        for arg in sys.argv[1:]:
            print(arg)
            rebuild_screenshot(arg)