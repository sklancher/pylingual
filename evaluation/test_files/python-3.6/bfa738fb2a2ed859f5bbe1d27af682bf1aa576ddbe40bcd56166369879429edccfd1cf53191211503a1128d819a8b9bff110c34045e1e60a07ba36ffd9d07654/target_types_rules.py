"""Rules for the core Python target types.

This is a separate module to avoid circular dependencies. Note that all types used by call sites are
defined in `target_types.py`.
"""
import dataclasses
import logging
import os.path
from collections import defaultdict
from dataclasses import dataclass
from itertools import chain
from typing import DefaultDict, Dict, Generator, Optional, Tuple, cast
from pants.backend.python.dependency_inference.module_mapper import PythonModuleOwners, PythonModuleOwnersRequest
from pants.backend.python.dependency_inference.rules import import_rules
from pants.backend.python.dependency_inference.subsystem import AmbiguityResolution, PythonInferSubsystem
from pants.backend.python.goals.setup_py import InvalidEntryPoint
from pants.backend.python.subsystems.setup import PythonSetup
from pants.backend.python.target_types import EntryPoint, InterpreterConstraintsField, PexBinariesGeneratorTarget, PexBinary, PexBinaryDependenciesField, PexEntryPointField, PexEntryPointsField, PythonDistributionDependenciesField, PythonDistributionEntryPoint, PythonDistributionEntryPointsField, PythonFilesGeneratorSettingsRequest, PythonProvidesField, PythonResolveField, ResolvedPexEntryPoint, ResolvedPythonDistributionEntryPoints, ResolvePexEntryPointRequest, ResolvePythonDistributionEntryPointsRequest
from pants.backend.python.util_rules.interpreter_constraints import interpreter_constraints_contains
from pants.engine.addresses import Address, Addresses, UnparsedAddressInputs
from pants.engine.fs import GlobMatchErrorBehavior, PathGlobs, Paths
from pants.engine.rules import Get, MultiGet, collect_rules, rule
from pants.engine.target import DependenciesRequest, ExplicitlyProvidedDependencies, FieldDefaultFactoryRequest, FieldDefaultFactoryResult, FieldSet, GeneratedTargets, GenerateTargetsRequest, InferDependenciesRequest, InferredDependencies, InvalidFieldException, TargetFilesGeneratorSettings, TargetFilesGeneratorSettingsRequest, Targets, ValidatedDependencies, ValidateDependenciesRequest, WrappedTarget, WrappedTargetRequest
from pants.engine.unions import UnionMembership, UnionRule
from pants.source.source_root import SourceRoot, SourceRootRequest
from pants.util.docutil import doc_url
from pants.util.frozendict import FrozenDict
from pants.util.ordered_set import OrderedSet
from pants.util.strutil import bullet_list, softwrap
logger = logging.getLogger(__name__)

@rule
def python_files_generator_settings(_: PythonFilesGeneratorSettingsRequest, python_infer: PythonInferSubsystem) -> TargetFilesGeneratorSettings:
    return TargetFilesGeneratorSettings(add_dependencies_on_all_siblings=not python_infer.imports)

class GenerateTargetsFromPexBinaries(GenerateTargetsRequest):
    generate_from = PexBinariesGeneratorTarget

@rule
async def generate_targets_from_pex_binaries(request: GenerateTargetsFromPexBinaries, union_membership: UnionMembership) -> GeneratedTargets:
    generator_addr = request.template_address
    entry_points_field = request.generator[PexEntryPointsField].value or []
    overrides = request.require_unparametrized_overrides()

    def create_pex_binary(entry_point_spec: str) -> PexBinary:
        return PexBinary({PexEntryPointField.alias: entry_point_spec, **request.template, **overrides.pop(entry_point_spec, {})}, generator_addr.create_generated(entry_point_spec.replace(':', '-')), union_membership, residence_dir=generator_addr.spec_path)
    pex_binaries = [create_pex_binary(entry_point) for entry_point in entry_points_field]
    if overrides:
        raise InvalidFieldException(softwrap(f"\n                Unused key in the `overrides` field for {generator_addr}:\n                {sorted(overrides)}\n\n                Tip: if you'd like to override a field's value for every `{PexBinary.alias}` target\n                generated by this target, change the field directly on this target rather than using\n                the `overrides` field.\n                "))
    return GeneratedTargets(request.generator, pex_binaries)

@rule(desc='Determining the entry point for a `pex_binary` target')
async def resolve_pex_entry_point(request: ResolvePexEntryPointRequest) -> ResolvedPexEntryPoint:
    ep_val = request.entry_point_field.value
    if ep_val is None:
        return ResolvedPexEntryPoint(None, file_name_used=False)
    address = request.entry_point_field.address
    if not ep_val.module.endswith('.py'):
        return ResolvedPexEntryPoint(ep_val, file_name_used=False)
    full_glob = os.path.join(address.spec_path, ep_val.module)
    entry_point_paths = await Get(Paths, PathGlobs([full_glob], glob_match_error_behavior=GlobMatchErrorBehavior.error, description_of_origin=f"{address}'s `{request.entry_point_field.alias}` field"))
    if len(entry_point_paths.files) != 1:
        raise InvalidFieldException(softwrap(f'\n                Multiple files matched for the `{request.entry_point_field.alias}`\n                {ep_val.spec!r} for the target {address}, but only one file expected. Are you using\n                a glob, rather than a file name?\n\n                All matching files: {list(entry_point_paths.files)}.\n                '))
    entry_point_path = entry_point_paths.files[0]
    source_root = await Get(SourceRoot, SourceRootRequest, SourceRootRequest.for_file(entry_point_path))
    stripped_source_path = os.path.relpath(entry_point_path, source_root.path)
    (module_base, _) = os.path.splitext(stripped_source_path)
    normalized_path = module_base.replace(os.path.sep, '.')
    return ResolvedPexEntryPoint(dataclasses.replace(ep_val, module=normalized_path), file_name_used=True)

@dataclass(frozen=True)
class PexBinaryEntryPointDependencyInferenceFieldSet(FieldSet):
    required_fields = (PexBinaryDependenciesField, PexEntryPointField, PythonResolveField)
    dependencies: PexBinaryDependenciesField
    entry_point: PexEntryPointField
    resolve: PythonResolveField

class InferPexBinaryEntryPointDependency(InferDependenciesRequest):
    infer_from = PexBinaryEntryPointDependencyInferenceFieldSet

@rule(desc='Inferring dependency from the pex_binary `entry_point` field')
async def infer_pex_binary_entry_point_dependency(request: InferPexBinaryEntryPointDependency, python_infer_subsystem: PythonInferSubsystem, python_setup: PythonSetup) -> InferredDependencies:
    if not python_infer_subsystem.entry_points:
        return InferredDependencies([])
    entry_point_field = request.field_set.entry_point
    if entry_point_field.value is None:
        return InferredDependencies([])
    (explicitly_provided_deps, entry_point) = await MultiGet(Get(ExplicitlyProvidedDependencies, DependenciesRequest(request.field_set.dependencies)), Get(ResolvedPexEntryPoint, ResolvePexEntryPointRequest(entry_point_field)))
    if entry_point.val is None:
        return InferredDependencies([])
    locality = None
    if python_infer_subsystem.ambiguity_resolution == AmbiguityResolution.by_source_root:
        source_root = await Get(SourceRoot, SourceRootRequest, SourceRootRequest.for_address(request.field_set.address))
        locality = source_root.path
    owners = await Get(PythonModuleOwners, PythonModuleOwnersRequest(entry_point.val.module, resolve=request.field_set.resolve.normalized_value(python_setup), locality=locality))
    address = request.field_set.address
    explicitly_provided_deps.maybe_warn_of_ambiguous_dependency_inference(owners.ambiguous, address, owners_must_be_ancestors=entry_point.file_name_used, import_reference='module', context=softwrap(f'\n            The pex_binary target {address} has the field\n            `entry_point={repr(entry_point_field.value.spec)}`, which\n            maps to the Python module `{entry_point.val.module}`\n            '))
    maybe_disambiguated = explicitly_provided_deps.disambiguated(owners.ambiguous, owners_must_be_ancestors=entry_point.file_name_used)
    unambiguous_owners = owners.unambiguous or ((maybe_disambiguated,) if maybe_disambiguated else ())
    return InferredDependencies(unambiguous_owners)
_EntryPointsDictType = Dict[str, Dict[str, str]]

def _classify_entry_points(all_entry_points: _EntryPointsDictType) -> Generator[Tuple[bool, str, str, str], None, None]:
    """Looks at each entry point to see if it is a target address or not.

    Yields tuples: is_target, category, name, entry_point_str.
    """
    for (category, entry_points) in all_entry_points.items():
        for (name, entry_point_str) in entry_points.items():
            yield (entry_point_str.startswith(':') or '/' in entry_point_str, category, name, entry_point_str)

@rule(desc='Determining the entry points for a `python_distribution` target')
async def resolve_python_distribution_entry_points(request: ResolvePythonDistributionEntryPointsRequest) -> ResolvedPythonDistributionEntryPoints:
    if request.entry_points_field:
        if request.entry_points_field.value is None:
            return ResolvedPythonDistributionEntryPoints()
        address = request.entry_points_field.address
        all_entry_points = cast(_EntryPointsDictType, request.entry_points_field.value)
        description_of_origin = f'the `{request.entry_points_field.alias}` field from the target {address}'
    elif request.provides_field:
        address = request.provides_field.address
        provides_field_value = cast(_EntryPointsDictType, request.provides_field.value.kwargs.get('entry_points') or {})
        if not provides_field_value:
            return ResolvedPythonDistributionEntryPoints()
        all_entry_points = provides_field_value
        description_of_origin = softwrap(f'\n            the `entry_points` argument from the `{request.provides_field.alias}` field from\n            the target {address}\n            ')
    else:
        return ResolvedPythonDistributionEntryPoints()
    classified_entry_points = list(_classify_entry_points(all_entry_points))
    target_refs = [entry_point_str for (is_target, _, _, entry_point_str) in classified_entry_points if is_target]
    target_addresses = await Get(Addresses, UnparsedAddressInputs(target_refs, owning_address=address, description_of_origin=description_of_origin))
    address_by_ref = dict(zip(target_refs, target_addresses))
    targets = await Get(Targets, Addresses, target_addresses)
    for target in targets:
        if not target.has_field(PexEntryPointField):
            raise InvalidEntryPoint(softwrap(f"""\n                    All target addresses in the entry_points field must be for pex_binary targets,\n                    but the target {address} includes the value {target.address}, which has the\n                    target type {target.alias}.\n\n                    Alternatively, you can use a module like "project.app:main".\n                    See {doc_url('python-distributions')}.\n                    """))
    binary_entry_points = await MultiGet((Get(ResolvedPexEntryPoint, ResolvePexEntryPointRequest(target[PexEntryPointField])) for target in targets))
    binary_entry_point_by_address = {target.address: entry_point for (target, entry_point) in zip(targets, binary_entry_points)}
    entry_points: DefaultDict[str, Dict[str, PythonDistributionEntryPoint]] = defaultdict(dict)
    for (is_target, category, name, ref) in classified_entry_points:
        owner: Optional[Address] = None
        if is_target:
            owner = address_by_ref[ref]
            entry_point = binary_entry_point_by_address[owner].val
            if entry_point is None:
                logger.warning(softwrap(f'\n                        The entry point {name} in {category} references a pex_binary target {ref}\n                        which does not set `entry_point`. Skipping.\n                        '))
                continue
        else:
            entry_point = EntryPoint.parse(ref, f'{name} for {address} {category}')
        if category in ['console_scripts', 'gui_scripts'] and (not entry_point.function):
            url = 'https://python-packaging.readthedocs.io/en/latest/command-line-scripts.html#the-console-scripts-entry-point'
            raise InvalidEntryPoint(softwrap(f'\n                    Every entry point in `{category}` for {address} must end in the format\n                    `:my_func`, but {name} set it to {entry_point.spec!r}. For example, set\n                    `entry_points={{"{category}": {{"{name}": "{entry_point.module}:main}} }}`. See\n                    {url}.\n                    '))
        entry_points[category][name] = PythonDistributionEntryPoint(entry_point, owner)
    return ResolvedPythonDistributionEntryPoints(FrozenDict({category: FrozenDict(entry_points) for (category, entry_points) in entry_points.items()}))

@dataclass(frozen=True)
class PythonDistributionDependenciesInferenceFieldSet(FieldSet):
    required_fields = (PythonDistributionDependenciesField, PythonDistributionEntryPointsField, PythonProvidesField)
    dependencies: PythonDistributionDependenciesField
    entry_points: PythonDistributionEntryPointsField
    provides: PythonProvidesField

class InferPythonDistributionDependencies(InferDependenciesRequest):
    infer_from = PythonDistributionDependenciesInferenceFieldSet

@rule
async def infer_python_distribution_dependencies(request: InferPythonDistributionDependencies, python_infer_subsystem: PythonInferSubsystem) -> InferredDependencies:
    """Infer dependencies that we can infer from entry points in the distribution."""
    if not python_infer_subsystem.entry_points:
        return InferredDependencies([])
    (explicitly_provided_deps, distribution_entry_points, provides_entry_points) = await MultiGet(Get(ExplicitlyProvidedDependencies, DependenciesRequest(request.field_set.dependencies)), Get(ResolvedPythonDistributionEntryPoints, ResolvePythonDistributionEntryPointsRequest(entry_points_field=request.field_set.entry_points)), Get(ResolvedPythonDistributionEntryPoints, ResolvePythonDistributionEntryPointsRequest(provides_field=request.field_set.provides)))
    address = request.field_set.address
    all_module_entry_points = [(category, name, entry_point) for (category, entry_points) in chain(distribution_entry_points.explicit_modules.items(), provides_entry_points.explicit_modules.items()) for (name, entry_point) in entry_points.items()]
    all_module_owners = iter(await MultiGet((Get(PythonModuleOwners, PythonModuleOwnersRequest(entry_point.module, resolve=None)) for (_, _, entry_point) in all_module_entry_points)))
    module_owners: OrderedSet[Address] = OrderedSet()
    for ((category, name, entry_point), owners) in zip(all_module_entry_points, all_module_owners):
        field_str = repr({category: {name: entry_point.spec}})
        explicitly_provided_deps.maybe_warn_of_ambiguous_dependency_inference(owners.ambiguous, address, import_reference='module', context=softwrap(f'\n                The python_distribution target {address} has the field\n                `entry_points={field_str}`, which maps to the Python module\n                `{entry_point.module}`\n                '))
        maybe_disambiguated = explicitly_provided_deps.disambiguated(owners.ambiguous)
        unambiguous_owners = owners.unambiguous or ((maybe_disambiguated,) if maybe_disambiguated else ())
        module_owners.update(unambiguous_owners)
    return InferredDependencies(Addresses(module_owners) + distribution_entry_points.pex_binary_addresses + provides_entry_points.pex_binary_addresses)

class PythonResolveFieldDefaultFactoryRequest(FieldDefaultFactoryRequest):
    field_type = PythonResolveField

@rule
def python_resolve_field_default_factory(request: PythonResolveFieldDefaultFactoryRequest, python_setup: PythonSetup) -> FieldDefaultFactoryResult:
    return FieldDefaultFactoryResult(lambda f: f.normalized_value(python_setup))

@dataclass(frozen=True)
class DependencyValidationFieldSet(FieldSet):
    required_fields = (InterpreterConstraintsField,)
    interpreter_constraints: InterpreterConstraintsField

class PythonValidateDependenciesRequest(ValidateDependenciesRequest):
    field_set_type = DependencyValidationFieldSet

@rule
async def validate_python_dependencies(request: PythonValidateDependenciesRequest, python_setup: PythonSetup) -> ValidatedDependencies:
    dependencies = await MultiGet((Get(WrappedTarget, WrappedTargetRequest(d, description_of_origin=f'the dependencies of {request.field_set.address}')) for d in request.dependencies))
    target_ics = request.field_set.interpreter_constraints.value_or_global_default(python_setup)
    non_subset_items = []
    for dep in dependencies:
        if not dep.target.has_field(InterpreterConstraintsField):
            continue
        dep_ics = dep.target[InterpreterConstraintsField].value_or_global_default(python_setup)
        if not interpreter_constraints_contains(dep_ics, target_ics, python_setup.interpreter_versions_universe):
            non_subset_items.append(f'{dep_ics}: {dep.target.address}')
    if non_subset_items:
        raise InvalidFieldException(softwrap(f"\n            The target {request.field_set.address} has the `interpreter_constraints` {target_ics},\n            which are not a subset of the `interpreter_constraints` of some of its dependencies:\n\n            {bullet_list(sorted(non_subset_items))}\n\n            To fix this, you should likely adjust {request.field_set.address}'s\n            `interpreter_constraints` to match the narrowest range in the above list.\n            "))
    return ValidatedDependencies()

def rules():
    return (*collect_rules(), *import_rules(), UnionRule(FieldDefaultFactoryRequest, PythonResolveFieldDefaultFactoryRequest), UnionRule(TargetFilesGeneratorSettingsRequest, PythonFilesGeneratorSettingsRequest), UnionRule(GenerateTargetsRequest, GenerateTargetsFromPexBinaries), UnionRule(InferDependenciesRequest, InferPexBinaryEntryPointDependency), UnionRule(InferDependenciesRequest, InferPythonDistributionDependencies), UnionRule(ValidateDependenciesRequest, PythonValidateDependenciesRequest))